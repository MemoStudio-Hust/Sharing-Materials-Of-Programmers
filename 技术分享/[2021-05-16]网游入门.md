# <p align="center">网游入门
#####   <p align="right">By黎梓涛</p>
#####   <p align="right">QQ：790494517</p>
---


#### 在做网游的时候，我们都会自然而然想到几个问题
1. 发送什么数据（比如你掉了点血，我是把整个人物所有状态属性全发送，还是部分比如血、蓝、CD等，还是只发送血的单独数据），也就是服务器应该如何序列化数据的问题
2. 游戏逻辑在哪计算（客户端还是服务器还是两个都计算，客户端和服务器的计算结果怎么保证一样，怎么防外挂）
3. 数据应该发给谁（你看不见或者可忽略的用户，服务器还要发送给你他的所有数据吗（这其实还涉及到外挂透视等），还是只是部分数据，又是哪部分数据呢）
4. 有延迟的情况下如何尽量保持同步（帧同步和状态同步）
5. 服务器发送数据时，应该考虑数据的优先级和重要程度，有些数据即使重要，丢包了可能也不必重发
---

#### 网络游戏相关知识还是不少，我这次讲的主要是以下两点
1. 序列化和反序列化
2. 帧同步
---

## 序列化
1. 序列化数据的时候，应该注意什么？
   1. 什么方式序列化
   2. 非内置类型怎么序列化
   3. 字节序（大端、小端、网络）
   4. 如何节约发送数据大小
<br/>

1. 什么方式序列化
   - 当然最好以流的方式序列化和反序列化，有利于掩藏关于发送的实现细节，方便使用和维护，降低耦合性。
<br/>

3. 非内置类型怎么序列化
   1. 显然服务器不能直接把指针和引用发给客户端，两台电脑上相同地址的数据一般不同，如果类里面有STL的一些容器等，显然不能直接发个容器过去
   2. 指针和引用的话，可以给每个对象实例一个唯一标识符，通过序列化标识符，使得反序列化时，客户端能够找到指针或者引用指向的对象（如果反序列化时，该对象由于网络等原因还未发送至客户端的话，可以暂时忽略，直到跟踪到该对象）。这种方式类似于注册表的实现。
   3. 容器的话，按照顺序序列化容器的每个元素即可
<br/>

4. 字节序（大端、小端、网络）
   1. 下图是0x0102这一数据在系统中存储的顺序，从左到右为内存中的低位到高位
   2. X86和X64和ios和（Xbox one和PlayStation 3及以后的版本）等一般都是小端
   3. 大端的比较少，IBM和Oracle的非个人电脑一般是大端
   4. 大端字节序的顺序适合人们处理数字的方式，而且可以快速判断数据正负和大小。那么为什么要使小端字节序呢？这是因为小端字节序的效率比大端字节序要高，在计算机电路中（电路知识终于派上用场了），先对低字节数据进行处理；而且强制转换可以不调整字节内容。
![img](https://www.hualigs.cn/image/609e767b7fec4.jpg)
<br/>

5. 如何节约发送数据大小
   1. 有很多高大上的方法（我很多也还没看过），比如赫夫曼编码、算术编码、gamma编码、行程编码、熵编码等。
   2. 熵编码时很普遍的一种方法，所以我略微讲一讲它。熵编码是信息论的一个主题，它利用数据的不确定性进行数据压缩，含有期望数据的数据包比非期望蕴含更少信息或熵，因此，发送期望数据时应该比非期望数据发送更少的比特。
   3. 比如Char name[100]，显然不是每个人的名字都会占满整个字符串，发送该字符串大小和字符串数据即可。如果一个游戏中要发生玩家Y坐标值，假设玩家在地上概率为P，那么可以发送一个true或者一个false加y的int值，发送比特的数学期望由32变成P+33（1-P）=33-32P，在忽略方差和具体游戏等的理想情况下，只要P>1/32，那么发送信息的熵就小了。还可以把浮点数忽略一定精度拆分为一些定点值来，还有几何压缩等。
   4. 比如一个int只需要发送前4位，后面28位都是没啥用的数据，那么可以只发4位。那么怎么求位数呢，这里介绍一个黑魔法（模板元编程）可以把运行期的负载转移到编译期。
![img](https://www.hualigs.cn/image/609e767b74958.jpg)
---


## 反序列化
1. 反序列化数据的时候，应该注意什么？
   1. 什么方式反序列化
   2. 数据包类型和发送了什么？
<br/>

2. 什么方式反序列化
   1. 反序列化时，如果想反序列化类，很多人第一时间想到dynamic_cast，但是这个需要C++的内置RTTI启动，其往往在游戏中是被禁用的，因为每一个多态类型都要额外的空间，更不好的一点是，它会使游戏对象系统和反序列化系统相互依赖，耦合度非常非常高，每次添加一个新的要反序列化的对象，都必须在两个系统添加相应代码，如果要移植反序列化系统到别的游戏，还要完全重写这块相互依赖的代码，而且游戏测试也很难做，因为没有加载游戏单元时甚至不能加载网络单元
   2. 显然以上设计不合理，应该是游戏代码依赖网络模块代码，网络模块代码则应该相对独立，能够运用于同一类型的大部分游戏。
   3. 我们由此可以联想到计算机的注册表和驱动补丁的实现原理，搞一个对象创建注册表出来，即通过hash得到类型标识符来唯一标识一个类，就能成功反序列化类了
   4. 实际上这种对象创建注册表的方式是C++的RTTI系统的一个定制版本，它是我们程序员为了特定类而手动创建的，所以在内存使用、类型标识符大小、交叉编译器的兼容性等方面比C++的typeid操作符有更多权限。
<br/>

3. 数据包类型和发送了什么？
   1. 数据包类型
        1. 创建游戏对象
        2. 更新游戏对象
        3. 销毁游戏对象
        4. 数据包发送的数据
   2. 数据类型
        1. 如果是状态数据
        2. 对象网络标识符
        3. 对象类标识符
        4. 序列化数据
    3. 如果是行为数据（RPC系统）,则2、3数据类型可有可无，4数据类型必须有，比如一次音乐播放就只需要1、4即可。
---

## 帧同步（lockstep）
1. 帧同步初认识
   1. 帧同步可以说是通过帧率延伸过来的，你可以把一个游戏看成一个巨大的状态机，所有的参与者都采用同一个逻辑帧率来不断的向前推进。
   2. 这个时间轴不是电脑上的本地时间，而是A、B、C联机时定义的一个时间轴。虚线分隔出来时间片称为turn，可以理解成一帧。箭头表示该玩家将自己的操作指令广播给其他玩家。
   3. 我们把一盘游戏看成一个大型的状态机，因为大家玩的是同一款的游戏，因此初始状态S0是相同的。在第一个turn结束时，所有玩家都接收到了一样的输入I，注意这里的I不是一个值，而是包含了当前游戏中所有玩家的操作指令集合。t1时刻所有玩家的电脑自行计算结果。由于F、S0和I是固定的，所以每个玩家电脑上计算出的下一个状态S1一定是相同的。
<img src="https://www.hualigs.cn/image/609e767b90a96.jpg" width="50%"/><img src="https://www.hualigs.cn/image/609e767b9aab9.jpg" width="50%"/>
   4. 游戏的前进分为一帧，这里的帧和游戏的渲染帧率并不是一个，只是借鉴了帧的概念，自定义的帧，我们称为turn。游戏的过程就是每一个turn不断向前推进，每一个玩家的turn推进速度一致。
   5. 每一帧只有当服务器集齐了所有玩家的操作指令，也就是输入确定了之后，才可以进行计算，进入下一个turn，否则就要等待最慢的玩家。之后再广播给所有的玩家。如此才能保证帧一致。
   6. Lockstep的游戏是严格按照turn向前推进的，如果有人延迟比较高，其他玩家必须等待该玩家跟上之后再继续计算，不存在某个玩家领先或落后其他玩家若干个turn的情况。使用Lockstep同步机制的游戏中，每个玩家的延迟都等于延迟最高的那个人。（最原始的帧同步是这样，而改进的乐观帧同步则不会等待最慢的玩家，它会定时广播，这也是实践当中应该采用的。）
   7. 由于大家的turn一致，以及输入固定，所以理论上每一步所有客户端的计算结果都一致的。然后服务器一般会和客户端一起计算这一步的结果，并且将结果发给每个客户端用来校验，可以防止客户端的一些作弊行为，也可以纠正客户端的计算错误。
<br/>

2. 帧同步简略原理
   1. 传统帧同步普遍要求网速RTT要在100ms以内，一般人数不超过8人，在这样的情况下，可以像单机游戏一样编写网络游戏。所有客户端任意时刻逻辑都是统一的，缺点是一个人卡机，所有人等待。
      1. 客户端定时（比如每五帧）上传控制信息。
      2. 服务器收到所有控制信息后广播给所有客户。
      3. 客户端用服务器发来的更新消息中的控制信息进行游戏。
      4. 如果客户端进行到下一个关键帧（5帧后）时没有收到服务器的更新消息则等待。
      5. 如果客户端进行到下一个关键帧时已经接收到了服务器的更新消息，则将上面的数据用于游戏，并采集当前鼠标键盘输入发送给服务器，同时继续进行下去。
      6. 服务端采集到所有数据后再次发送下一个关键帧更新消息。
   2. 这个等待关键帧更新数据的过程称为“帧锁定”
<br/>

3. 帧同步状态机
   1. 客户端逻辑：
      1. 判断当前帧F是否关键帧K1，如果不是跳转7。
      2. 如果是关键帧，则察看有没有K1的UPDATE数据，如果没有的话重复2等待。
      3. 采集当前K1的输入作为CTRL数据与K1编号一起发送给服务器
      4. 从UPDATE K1中得到下一个关键帧的号码K2以及到下一个关键帧之间的输入数据I。
      5. 从这个关键帧到下 一个关键帧K2之间的虚拟输入都用I。
      6. 令K1 = K2。
      7. 执行该帧逻辑
      8. 跳转1
   2. 服务端逻辑：
      1. 收集所有客户端本关键帧K1的CTRL数据（Ctrl-K）等待知道收集完成所有的CTRL-K。
      2. 根据所有CTRL-K，计算下一个关键帧K2的Update，计算再下一个关键帧的编号K3。
      3. 将Update发送给所有客户端
      4. 令K1=K2
      5. 跳转1
<br/>

4. 帧同步延迟处理
   1. 如果在某一个帧客户端没有收到服务端的包，就会导致客户端无指令可执行，那么逻辑层就暂停下来了。等到网络正常时，一次性收到多个帧的包，快速执行这些帧来赶上进度。王者就是这样
   2. 如果服务端收到一个非当前帧的包时，设定一个timeout，如果是多久之前的包则忽略，即默认该玩家什么都没干，或者塞入之后的队列，下一帧派发，即仅仅是该玩家的操作卡顿（延迟）了。
<br/>

5. 乐观帧同步
   - 针对传统严格帧锁定算法中网速慢会卡到网速快的问题，实践中线上动作游戏通常用“定时不等待”的乐观方式再每次Interval时钟发生时固定将操作广播给所有用户，不依赖具体每个玩家是否有操作更新：
   1. 单个用户当前键盘上下左右攻击跳跃是否按下用一个32位整数描述，服务端描述一局游戏中最多8玩家的键盘操作为：int player_keyboards[8];
   2. 服务端每秒钟20-50次向所有客户端发送更新消息（包含所有客户端的操作和递增的帧号）：update=（FrameID，player_keyboards）
   3. 客户端就像播放游戏录像一样不停的播放这些包含每帧所有玩家操作的 update消息。
   4. 客户端如果没有update数据了，就必须等待，直到有新的数据到来。
   5. 客户端如果一下子收到很多连续的update，则快进播放。
   6. 客户端只有按键按下或者放开，就会发送消息给服务端（而不是到每帧开始才采集键盘），消息只包含一个整数。服务端收到以后，改写player_keyboards
 <br/>

6. 帧同步模型
   1. 前面讲的帧同步都是最原始最传统的一个模型,在实际应用当中，往往有各种魔改版的帧同步，甚至帧同步和状态同步各自的一些东西结合起来用。（比如守望先锋就是很好的结合了两者的优点）
   1. 当然这些改进，一般都是对应到特定游戏类型的。有些改进只适合FPS，有些只适合RTS，有些只适合MOBA。
</br>

7. 帧同步断线重连
   - 如果需要实现断线重连的功能，需要服务端下发从游戏开局到当前的所有包，客户端快速运行这些指令来达到和当前其他客户端状态的同步。
</br>

8. 帧同步防作弊
    - 帧同步的作弊是一个非常严峻的问题，因为所有操作都在客户端进行，如果一个客户端声称自己击杀了大龙，消息被发送给了服务端，此时就需要服务端有个判断功能，也就是服务端要充当裁判，较好的做法是同时在服务端也运行一个游戏逻辑（也就是之前提到的最好有一份客户端与服务端公用的逻辑），从而对客户端发过来的指令做出判断
</br>

9. 帧同步回滚
    1. 客户端的时间，是领先服务器的，客户端不需要服务器确认帧返回才执行指令，而是玩家输入，立刻执行（其他玩家的输入，按照其最近一个输入做预测，或者其他更优化的预测方案），然后将指令发送给服务器，服务器收到后给客户端确认，客户端收到确认后，如果服务确认的操作，和之前执行的一样（自己和其他玩家预测的操作），将不做任何改变，如果不一样（预测错误），就会将游戏整体逻辑回滚到最后一次服务器确认的正确帧，然后再追上当前客户端的帧。
    2. 举个例子
        1. 当前客户端（A，B）执行到100帧，服务器执行到97帧。在100帧的时候，A执行了移动，B执行了攻击，A和B都通知服务器：我已经执行到100帧，我的操作是移动（A），攻击（B）。服务器在自己的98帧或99帧收到了A，B的消息，存在对应帧的操作数据中，等服务器执行到100帧的时候（或提前），将这个数据广播给AB。
        2. 回到客户端，A和B发送给服务器后立马执行100帧，A执行移动，预测B执行攻击（可能B的99帧也是攻击）。而B执行攻击，预测A执行攻击，A和B各自预测对方的操作。
        3. 在A和B执行完100帧后，他们会各自保存100帧的状态快照，以及100帧各自的操作（包括预测的操作），以备万一预测错误，做逻辑回滚。
        4. 执行几帧后，A，B来到了103帧，服务器到了100帧，他开始广播数据给AB，在一定延迟后，AB收到了服务器确认的100帧的数据，这时候，AB可能已经执行到104了。A和B各自去核对服务器的数据和自己预测的数据是否相同。例如A核对后，100帧的操作，和自己预测的一样，A不做任何处理，继续往前。而B核对后，发现在100帧，B对A的预测，和服务器确认的A的操作，是不一样的（B预测的是攻击，而实际A的操作是移动），B就回滚到上一个确认一样的帧，即99帧，然后根据确认的100帧操作去执行100帧，然后快速执行101~103的帧逻辑，之后继续执行104帧，其中（101-104）还是预测的逻辑帧。
        5. 这样，对于网络好的玩家，和网络不好的玩家，都不会互相影响，不会像原始lockstep一样，网络好的玩家，会被网络不好的玩家lock住。也不会被网络延迟lock住，客户端可以一直往前预测。
        6. 对于网络好的玩家（A），可以动态调整，让客户端领先服务器少一些，尽量减少预测量，就会尽量减少回滚，例如网络好的，可能客户端只领先2~3帧。
        7. 对于网络不好的玩家（B），动态调整，领先服务器多一些，例如领先5帧。
        8. 那么，A可能预测错的情况，只有2~3帧，而网络不好的B，可能预测错误的帧有5帧。通过优化的预测技术，和消息通知的优化，可以进一步减少A和B的预测错误率。对于A而言，战斗是顺畅的，手感很好，少数情况的回滚，优化好了，并不会带来卡顿和延迟感。
        9. 重点优化的是B，即网络不好的玩家，他的操作体验。因为客户端不等待服务器确认，就执行操作，所以B的操作手感，和A是一致的，区别只在于，B因为延迟，预测了比较多的帧，可能导致预测错，回滚会多一些。比如按照B的预测，应该在100帧击中A，但是因为预测错误A的操作，回滚重新执行后，B可能在100帧不会击中A。这对于B来说，通过插值和一些平滑方式，B的感受是不会有太大区别的，因为B看自己，操作自己都是及时反馈的，他感觉自己是平滑的。
    3. 不过，回滚这种延迟补偿并不是一个万能的优化方式，采用与否应该由游戏的类型与设计决定。
    考虑一个ACT类型的网游，玩家A延迟比较低、玩家B延迟比较高。在A的客户端上，玩家A在T1 时间靠近B，而后立刻执行了一个后滚操作，发送到服务器。在B的客户端上，同样在T1时 间发起进攻，然后发送命令到服务器。由于A的延迟低，服务器先收到了A的指令，A开始 后滚操作，这时候A已经脱离了B的攻击范围。然后当B的指令到达服务器的时候，如果采用 延迟补偿，就需要把A回滚到之前的位置结果就是A收到了B的攻击，这对A来说显然是不公平的。
    如果该情况发生在FPS里面，就不会有很大的问题，因为A根本不知道B什么时候瞄准的A
<img src="https://www.hualigs.cn/image/609e767ba0a8a.jpg"/>
<br/>

10. 帧同步延迟和卡顿
    1. 每一帧数据包较小的话，延迟低，但是容易卡顿
    2. 每一帧数据包较大的话，卡顿少，但是延迟高
    3. 比如我现在已经收到第N帧，只有当我收到第N+1帧的时候，第N这一帧我才可以执行。服务器会按照一定的频率，不同的给大家同步帧编号，包括这一帧的输入带给客户端，如果带一帧给你的数据你拿到之后就执行，下一帧数据没来就不能执行，它的结果就是卡顿。
    4. 网络绝对理想的情况下还好，但现实的网络环境不是这样的。帧同步要解决问题就是调试buffer，以前有动态的buffer，它有1到n这样的缓冲区，根据网络抖动的情况，收入然后放到队列里面。
    5. 这个buffer的大小，会影响到延迟和卡顿。如果buffer越小，你的延迟就越低，你拿到以后你不需要缓冲等待，马上就可以执行。但是如果下一帧没来，buffer很小，你就不能执行，最终导致的结果你的延迟还好，但是卡顿很明显。
    6. 《王者荣耀》最后做到的buffer是零，它不需要buffer，服务器给了我n，马上知道是n，我收到n，我知道下一次肯定是n+1，所以我收到n之后马上就把n这一帧的输入执行了。那么为什么不卡顿了，画面不抖动了？
    7. 关键点是本地插值平滑加逻辑与表现分离。客户端只负责一些模型、动画、它的位置，它会根据绑定的逻辑对象状态、速度、方向来进行一个插值，这样可以做到我们的逻辑帧率和渲染帧率不一样，但是做了插值平滑和逻辑表现分离，画面不抖了，延迟感也是很好的。
    8. 我们经常见到角色A和B，有些客户端A在左B在右，有些是A在右B在左，帧同步逻辑上面AB之间的距离和坐标都是完全一样，但是画面上看到他们可能会不重合，那就是你把它们分离之后的表现。网络极其好的情况下，它应该是重合的，但是在网络差的情况下，可能会有些偏差。这里面是最重要的一块优化。
<br/>

11. 帧同步优缺点
    1. 优点
        1. 由于只同步操作，数据量受游戏内单位多少的影响较小。
        2. 天生自带战斗回放，服务端只需把开局所有操作记录下来就行。
    2. 缺点
        1. 由于计算在客户端，较难防外挂，特别是全图外挂。
        2. 调试难度大，某一帧不同步之后会产生蝴蝶效应毁掉整场战斗。
<br/>

12. 哪些游戏需要使用帧同步呢？
    1. 多人实时对战游戏（FPS、RTS、MOBA等）
    2. 游戏中需要战斗回放功能
    3. 游戏中需要加速功能
    4. 需要服务器同步逻辑校验防止作弊（不过状态同步防作弊能力更强一些）
![](https://www.hualigs.cn/image/609e8516d00fd.jpg)
</br>

13. 帧同步和状态同步优缺点对比
![](https://www.hualigs.cn/image/609e85448808b.jpg)
</br>

14. 开热点或者NAT穿越来实现局域网小游戏
    1. 刚加入团队时做了个用局域网的小游戏，发现直接用IP服务器连不上客户端，这是因为路由器或者防火墙把自己IP改了，通俗的讲，就是自己的客户端和服务器在整个互联网中是通过路由器这一媒介与他人交流的，别人只认识和找的到路由器。
    2. 解决方法有很多，比如路由器上手动配置端口转发，不过显然绝大多数玩家都不会这个。也可以搞一台有公有网络的第三方服务器，通过UDP对NAT的穿越或者TCP打洞等多种方式来实现。
    3. 然而以上两种不是费脑麻烦（路由器怕是能被我配废）就是费钱（租不起服务器），最简单的就是开个热点就完事了。
---
